---
title: "Analysis"
output: html_document
---

```{r setup/libraries/read data/rename, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# libraries
library(tidyverse)

#library(psych)
source(file = "2a Functions.R") #should be cluster ready with this
```

# Open files
```{r open data}
adata_each <- readRDS("Data/final_each2022-06-03 02:34:19.rds") %>% 
  en_ingles()

adata_occ <- readRDS("Data/final_occupations_2022-06-11 22:45:53.rds") %>%
  en_ingles()

adata_amr <- readRDS("Data/final_amr_2022-05-25 10:41:28.rds")

```


# Macro

## Entropy

Check
```{r Entropy x population plot}
#theme?
#colour for smooth line?

library(scales)

options(scipen = 0)
pop_entropy <- ggplot(data = adata_each %>% dplyr::filter(entropy > 0), 
                      aes(x = bevoelkerung, y = entropy)) +
  geom_point(alpha = 0.01) +
  #log scale, base 10
  scale_x_continuous(trans = log10_trans(),
                     breaks = trans_breaks("log10", function(x) 10^x),
                     labels = trans_format("log10", math_format(10^.x))) +
  scale_y_continuous(trans = log10_trans(),
                     breaks = trans_breaks("log10", function(x) 10^x),
                     labels = trans_format("log10", math_format(10^.x))) +
  #smooth line
  geom_smooth(method = "lm", colour = "darkred") +
  #correlation coefficient, y eventuell 0.1
  ggpubr::stat_cor(method = "pearson", label.y.npc = 0.0) +
  #labels
  labs(x = "N", y = "Entropy") +
  # theme 
  theme_minimal()

pop_entropy

```

Check
```{r Entropy x AMR plot}
#add beta coefficient -> scaling on microdata
#einzelne anzeigen sind schwarz, amr sums sind gelb? industries sind orange, 
options(scipen = 0)

amr_entro <- adata_each %>% 
  group_by(AMR, bevoelkerung) %>% 
  summarise(mean_entropy = mean(entropy, na.rm = T))

pop_entropy <- ggplot(data = amr_entro, aes(x = bevoelkerung, y = mean_entropy)) +
  geom_point(alpha = 0.8, colour = "burlywood4") +
  #log scale, base 10
  scale_x_continuous(trans = log10_trans(),
                     breaks = trans_breaks("log10", function(x) 10^x),
                     labels = trans_format("log10", math_format(10^.x))) +
  scale_y_continuous(trans = log10_trans(),
                     breaks = trans_breaks("log10", function(x) 10^x),
                     labels = trans_format("log10", math_format(10^.x))) +
  geom_smooth(method = "lm", colour =  "darkred") +
  ggpubr::stat_cor(method = "pearson", label.y.npc = 0.0) +
  theme_minimal() +
  labs(x = "N", y = "Entropy")
pop_entropy


```


## Other measures
```{r, Types x population}
pop_typ <- ggplot(data = adata_each, aes(x = log(bevoelkerung, base = 10), y = types)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "lm") +
  ggpubr::stat_cor(method = "pearson")

pop_typ
```

```{r, pr_noun + population}
pop_noun <- ggplot(data = adata_each, aes(x = log(bevoelkerung, base = 10), y = sents)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "lm") +
  ggpubr::stat_cor(method = "pearson")

pop_noun

```



# Inter-industry

## Frequencies

```{r, frequencies per industry}
#histogram of frequencies, log(population) -> scaling observable for some industries

p <- ggplot(data = adata_each, aes(x = log(bevoelkerung, base = 10))) +
  geom_histogram(bins = 50) +
  #geom_smooth() +
  #geom_jitter() +
  facet_wrap(vars(industry))
p

```


## Boxplot of entropy

```{r, boxplot per industry}
box_pl <- ggplot(data = adata_each %>% dplyr::filter(industry %in% c("Agriculture, forestry, horticulture", "IT, computers, telecommunication")), aes(y = entropy)) +
  geom_boxplot() +
  facet_wrap(vars(industry))
box_pl


```


## Bootstrap 
```{r bootstrapped CIs entropy differences}
library(boot)

boots_function <- function(data,index){
  d <- data[index,]
  return(mean(d$entropy, na.rm = T))  
}

boots <- adata_each %>%
  group_split(industry) %>% 
  
  map_dfr(function(x){
    mean_entropy <- mean(x$entropy, na.rm = T)
    
    basic <- boot.ci(boot(x, boots_function, R = 10000), type = "basic")$basic
    CI.LL <- basic[4]
    CI.UL <- basic[5]
    
    res <- tibble(mean_entropy = round(mean_entropy, digits = 4),
                  CI.LL = round(CI.LL, digits = 4),
                  CI.UL = round(CI.UL, digits = 4))
    
    return(res)
    
    })
boots

saveRDS(boots, file = "Data/entropy_industry bootstrap_ci_26.05.rds")

```


check
```{r combine boots and plot CIs, fig.height=6, fig.width=10}
boots <- readRDS("Data/entropy_industry bootstrap_ci_26.05.rds")

industry_entropy_df <- adata_each %>% 
  group_by(industry) %>% 
  summarise(mean_entropy = round(mean(entropy, na.rm = T), digits = 4))

boots_entropy <- merge(industry_entropy_df, boots)

be <- ggplot(data = boots_entropy) +
  geom_col(aes(x = reorder(industry, mean_entropy), y = mean_entropy), fill = "darkorange") +
  scale_y_continuous(limits=c(6, 7.5),oob = rescale_none) +

  #errorbar 
  geom_errorbar(aes(x = industry, ymin = CI.LL, ymax = CI.UL),
                  position = "dodge", 
                  width = .5) +
  #color
  coord_flip() +
  labs(x =  "Industry", 
       y = "Mean entropy") + 
  theme(legend.position = "none")
    
be
```


```{r homskedasticity of entropy in industries}
#Variance of all industries, dataframe
comp_variance <- adata_amr %>% 
  group_by(industry) %>%
  summarise(var_entropy = var(mean_entropy, na.rm = T))

#Rule of thumb for Homoskedasticity: largest variance 1.5x smallest variance
max(comp_variance$var_entropy)
1.5 * min(comp_variance$var_entropy)
```

## Entropy and scaling per industry

```{r scaling/entropy, echo=FALSE}
# This function takes adata which was grouped by industry beforehand and returns scaling beta for each industry
scaling <- function(industry_tibble){
  
  model1 <- lm(formula = log(n) ~ log(population),
               data = industry_tibble)
  
  return(round(model1$coefficients[2], digits = 3))
}

#group by industry, calculate summaries e.g. scaling

adata_amr <- adata_each %>% 
  group_by(AMR, industry) %>% 
  summarise(n = n(), 
            population = mean(bevoelkerung),
            mean_entropy = mean(entropy, na.rm = T))

industry_data <- adata_amr %>% group_by(industry) %>%
  summarise(beta = scaling(cur_data()),
            mean_entropy = mean(mean_entropy, na.rm = T))

#plot
entropy_industry <- ggplot(data = industry_data, aes(x = mean_entropy, y = beta)) +
  geom_point(colour = "darkorange") +
  ggpubr::stat_cor(method = "pearson") +
  geom_smooth(method = "lm", colour = "darkred") +
  ggrepel::geom_text_repel(aes(label = industry)) +
  geom_hline(yintercept = 1, size = 0.2, linetype = "dotted") +
  labs(x = "Mean Entropy", y = "Scaling coefficient (beta)") +
  theme_minimal()
entropy_industry
```



# Intra-industry

```{r descriptives}

#Descriptives of all industries
adata_each  %>% select(entropy, industry) %>% describe.by(adata_each$industry)


```

## Beta estimates, models, regressions
Does the beta coefficient increase with population size in the seperate industry sectors?

### Uncorrected
Raw material extraction has the highest beta: 0.004716474483
A 1% increase in population is associated with a 0.04% increase in textual information density of job ads (elasticity).
-> Negative relationships as well, e.g. IT, computers, telecommunication -> weird

```{r intra industry model, results = 'asis', warning=FALSE, message=FALSE}
options(scipen = 999)

industry_model <- function(df) {
  lm(log(entropy) ~ log(bevoelkerung), data = df)
}

by_industry <- adata_each %>% 
  dplyr::filter(entropy > 0) %>% #drop cases where entropy is smaller than 1 -> undefefined if log(0)
  group_by(industry) %>%
  nest()

by_industry <- by_industry %>%
  mutate(model = map(data, industry_model))

models_by_industry <- by_industry %>% 
  mutate(tidy = map(model, broom::tidy)) %>% 
  select(-data, -model) %>%
  unnest(tidy) %>%
  dplyr::filter(term == "log(bevoelkerung)") %>%
  select(-term) %>%
  arrange(estimate)

models_by_industry
#xtable::xtable(models_by_industry)


```


### Single-industry model
```{r single industry model}
waste <- adata_each %>% dplyr::filter(industry == "Waste management, energy supply, water supply")

model <- lm(log(entropy) ~ log(bevoelkerung), data = waste)
summary(model)

```


### Entropy industry amr
```{r facet intra industry amr}

adata_amr <- adata_each %>% 
  group_by(AMR, industry) %>% 
  summarise(n = n(), 
            population = mean(bevoelkerung),
            mean_entropy = mean(entropy, na.rm = T))

e <- ggplot(data = adata_amr, aes(x = population, y = mean_entropy)) +
 geom_point(alpha = 0.5, colour = "burlywood4") +
  #log scale, base 10
  scale_x_continuous(trans = log10_trans(),
                     breaks = trans_breaks("log10", function(x) 10^x),
                     labels = trans_format("log10", math_format(10^.x))) +
  scale_y_continuous(trans = log10_trans(),
                     breaks = trans_breaks("log10", function(x) 10^x),
                     labels = trans_format("log10", math_format(10^.x))) +
  ggpubr::stat_cor(method = "pearson", label.y.npc = 0.1) +
  geom_smooth(method = "lm") +
  facet_wrap(vars(industry)) +
  geom_smooth(method = "lm", colour =  "darkred") +
  labs(y = "Mean entropy", x = "N") +
  theme_minimal()
  
e


```


```{r intra industry facet pop}
#entropy
e <- ggplot(data = adata_each, aes(x = bevoelkerung, y = entropy)) +
  geom_point(alpha = 0.01) +
  #log scale, base 10
  scale_x_continuous(trans = log10_trans(),
                     breaks = trans_breaks("log10", function(x) 10^x),
                     labels = trans_format("log10", math_format(10^.x))) +
  scale_y_continuous(trans = log10_trans(),
                     breaks = trans_breaks("log10", function(x) 10^x),
                     labels = trans_format("log10", math_format(10^.x))) +
  #smooth line
  geom_smooth(method = "lm", colour = "darkred") +
  #correlation coefficient, y eventuell 0.1
  ggpubr::stat_cor(method = "pearson", label.y.npc = 0.1) +
  geom_smooth(method = "lm", colour = "darkred") +
  facet_wrap(vars(industry))+
  theme_minimal() +
  labs(y = "Entropy", x = "N")
e

```



# Occupations

## Complex vs. non-complex
```{r  complex vs. non complex occ X AMR}
creatives <- adata_occ %>% 
  dplyr::filter(creative == 1) %>% 
  group_by(AMR) %>%
  summarise(n = n(),
            mean_entropy = mean(entropy, na.rm = T),
            population = mean(bevoelkerung))

non_creatives <- adata_occ %>% 
  dplyr::filter(creative == 0) %>%
  group_by(AMR) %>%
  summarise(n = n(),
            mean_entropy = mean(entropy, na.rm = T),
            population = mean(bevoelkerung))


#creative occupations x amr
c <- ggplot(data = creatives, aes(x = population, y = mean_entropy)) +
  geom_point(alpha = 0.8, colour = "burlywood4") +
  #log scale, base 10
  scale_x_continuous(trans = log10_trans(),
                     breaks = trans_breaks("log10", function(x) 10^x),
                     labels = trans_format("log10", math_format(10^.x))) +
  scale_y_continuous(trans = log10_trans(),
                     breaks = trans_breaks("log10", function(x) 10^x),
                     labels = trans_format("log10", math_format(10^.x))) +
  geom_smooth(method = "lm", colour =  "darkred") +
  ggpubr::stat_cor(method = "pearson", label.y.npc = 0.0) +
  theme_minimal() +
  labs(x = "N", y = "Entropy", title = "Complex occupations") 
c

#non-creative occupations x amr
nc <- ggplot(data = non_creatives, aes(x = population, y = mean_entropy)) +
  geom_point(alpha = 0.8, colour = "burlywood4") +
  #log scale, base 10
  scale_x_continuous(trans = log10_trans(),
                     breaks = trans_breaks("log10", function(x) 10^x),
                     labels = trans_format("log10", math_format(10^.x))) +
  scale_y_continuous(trans = log10_trans(),
                     breaks = trans_breaks("log10", function(x) 10^x),
                     labels = trans_format("log10", math_format(10^.x))) +
  geom_smooth(method = "lm", colour =  "darkred") +
  ggpubr::stat_cor(method = "pearson", label.y.npc = 0.0) +
  theme_minimal() +
  labs(x = "N", y = "Entropy", title = "Non-complex occupations")
nc

```

Scaling coefficients differ between occupation types (complex vs. non creative). Still, results don't support the hypothesis, that scaling is stronger for creative industries
```{r complex occupations beta models }
creatives <- adata_occ %>% 
  dplyr::filter(creative == 1) %>% 
  group_by(AMR) %>%
  summarise(n = n(),
            mean_entropy = mean(entropy, na.rm = T),
            population = mean(bevoelkerung))

non_creatives <- adata_occ %>% 
  dplyr::filter(creative == 0) %>%
  group_by(AMR) %>%
  summarise(n = n(),
            mean_entropy = mean(entropy, na.rm = T),
            population = mean(bevoelkerung))


model1_c <- lm(log(mean_entropy) ~ log(population), data = creatives)
summary(model1_c)


model1_c <- lm(log(mean_entropy) ~ log(population), data = non_creatives)
summary(model1_c)

```

## Major groups
knowledge complexity doesn't rise within major groups

```{r, facet isco major group X AMR}

entropy_occ_maj <- adata_occ %>% 
  group_by(AMR, occupation_major) %>% 
  summarise(n = n(), 
            population = mean(bevoelkerung),
            mean_entropy = mean(entropy, na.rm = T))

o <- ggplot(data = entropy_occ_maj, aes(x = population, y = mean_entropy)) +
 geom_point(alpha = 0.5, colour = "burlywood4") +
  #log scale, base 10
  scale_x_continuous(trans = log10_trans(),
                     breaks = trans_breaks("log10", function(x) 10^x),
                     labels = trans_format("log10", math_format(10^.x))) +
  scale_y_continuous(trans = log10_trans(),
                     breaks = trans_breaks("log10", function(x) 10^x),
                     labels = trans_format("log10", math_format(10^.x))) +
  ggpubr::stat_cor(method = "pearson", label.y.npc = 0.1) +
  geom_smooth(method = "lm") +
  facet_wrap(vars(occupation_major)) +
  geom_smooth(method = "lm", colour =  "darkred") +
  labs(y = "Mean entropy", x = "N") +
  theme_minimal()
o


```


## Differences in knowledge complexity
```{r}
diff

```


# Maps

```{r, map of all jobads}

amr_n <- adata_each %>% group_by(AMR) %>% summarise(n_anzeigen = n())

amr_sf <- sf::st_read("Shapefiles/Deutschland/amr250/AMR250.shp") %>%
  inner_join(amr_n, by = "AMR")

a <- ggplot(data = amr_sf) +
  geom_sf(aes(fill=n_anzeigen)) +
  coord_sf(datum = NA) +
  scale_fill_continuous(low = "white", high = "darkred") +
  labs(fill = "Number of Job Ads") +
  theme_minimal() 
a

```



```{r, map of knowledge complexity x AMR}

amr_entro <- adata_each %>% 
  group_by(AMR, bevoelkerung) %>% 
  summarise(mean_entropy = mean(entropy, na.rm = T))

amr_sf <- sf::st_read("Shapefiles/Deutschland/amr250/AMR250.shp") %>%
  inner_join(amr_entro, by = "AMR")

a <- ggplot(data = amr_sf) +
  geom_sf(aes(fill=mean_entropy)) +
  coord_sf(datum = NA) +
  scale_fill_continuous(low = "white", high = "darkred") +
  labs(fill = "Knowledge complexity") +
  theme_minimal() 
a

```



